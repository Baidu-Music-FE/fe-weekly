# 懒执行表与里

这周浏览 github trending 无意间看到了 facebook 的一个叫做 [immutable-js][0] 的库，“不可更改”虽然表面看上去和“懒执行”没有什么交集，但事实上内在关系非常大。

现在纯粹的懒执行库里，比较有名的是 [lazy.js][1]，如果你有兴趣，可以先看看它的介绍，或者 wiki 相关概念。

## 动机

不多说废话，这里举个例子。比如有这样一个需求，A 同学现在有一些待处理的 url 数据在变量 url_list 里，A 需要使用 B 同学写的 map_url_list 函数处理这些数据，代码可能会写成这样：

```javascript
urls = map_url_list(url_list);

// 每点击一下，处理一个 url
$('#btn').click(function () {
    var url = urls.pop();
    // 处理 url...
});
```

功能解耦的好处是 A 不需要关心 B 怎么实现 map_url_list 函数的，A 只管调用即可。我们假设一下 B 的需求，map_url_list 函数可能长这样：

```javascript
var map_url_list = function (url_list) {
    return url_list.map(function (url, i) {
        return url + $('.url-' + i).length;
    });
}
```

上面这种实现可以说是最正常的想法，功能上来讲确实是无懈可击。但是 B 不知道的是，A 现在突然要处理 10 万条数据。由于这个函数需要循环 10 万次，这很可能让浏览器无法响应一会儿，直接影响用户体验。

当然坏处不止这一点，这个函数还产生了一个新的拥有 10 万条目的数组。虽然 V8 用了很多技巧将新字符串和旧字符串关联起来，没有耗费太多内存，但站在上层我们依然应该尽量精益求精。

## 表解决方案

这里开始就引入懒执行的具体概念了。我个人总结了下，其实核心思想就一句话：

> 在需要的时候才处理数据，而不是提前准备好数据。

按照这个想法，我们作为 B，应该优化一下自己的函数，可以这样写：

```javascript
var map_url_list = function (url_list) {
    var i = 0;
    return {
        pop: function () {
            var url = url_list[i++];
            return url + $('.url-' + i).length;
        }
    };
}
```

相比之前的函数，这个函数运行完毕，没有产生一次循环，瞬间就执行完了。A 在调用 `urls.pop()` 的时候，才会运行函数，换句话说只在用户点击目标的时候才运行一次，否则或者用户离开页面时一次多余的运算也没发生。

## 里思考

看上去这个函数很好的满足了需求，性能大概比之前那个快了 10 万倍，听上去很不错，但实际运用起来，像之前那么设计会出现很多问题。举个最简单的例子。如果 A 的代码是这样的：

```javascript
urls = map_url_list(url_list);

// 每点击一下，处理一个 url
$('#btn').click(function () {
    var url = urls.pop();
    // 处理 url...
});

// 每点击一下，增加一个 url
$('.add').click(function () {
    // 当然这里用 push 不会触发什么问题。
    url_list.unshift(this.dataset.url);
});
```

如果 url_list 是一个动态的值，那么 map_url_list 作为一个封闭的环境，它将不知所措。所以并不是任何情况下懒执行都能很好的适用。它的核心思想里我觉得还应该有：

> 懒执行通常需要通过牺牲安全性来提升性能。

为什么说是安全性呢？其实这个有点仁者见仁智者见智了，好比 clone 一份数组和直接依赖之前的数组，通常是 clone 一份再处理更安全。依赖和不安定总结伴而行。


[0]: https://github.com/facebook/immutable-js
[1]: https://github.com/dtao/lazy.js